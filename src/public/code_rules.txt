General:
    Core Technologies:
        Backend: Laravel
        Database: MongoDB
        Frontend Styling: Tailwind CSS
        Frontend Interactivity: Alpine.JS

    File Organization:
        - Each webpage has a primary controller and a primary Blade view file. These files are organized hierarchically by feature. For instance, a "Payroll" page within the "Finance" section will have its files located as follows:

            Controller: App/Http/Controllers/Finance/PayrollController.php
            Main View: resources/views/finance/payroll.blade.php
            Components: resources/views/components/finance/payroll/

    Webpage and Data Structure:
        - The construction and data flow of most webpage follows a precise pattern. Any webpage that does not follow the below outlined structure will be reffered to as a "custom" page and will be bespoke:

            Initial Load:
                - A GET route in routes/web.php points to the index() method of the page's primary controller.
                - This index() method gathers all necessary initial data and passes it to the primary Blade view.

            Primary View:
                - The primary view's role is strictly to structure the layout of the webpage and hold shared data. It is comprised of blade components.
                - It arranges these various Blade components, defining their visual presentation and dimensions. This includes making the components visual layout responsive.
                - The primary view recieves the data needed for initial page load from its primary controller and passes this data to the blade components as props.
                - The primary view is responsible for defining a local, feature-scoped Alpine.store. This store acts as a "Registry" for cross-component communication, specifically for handling "Dirty State" checks (unsaved changes) without tight coupling.

            Blade Components:
                - Blade components handle all user interactions and state changes using Alpine.JS. We do NOT use LiveWire. The components can be of three classes: User Input (visual), Data Bridge (headless), and Display (visual). Note, this is for all non-custom pages.
    
                User Input Components: These components contain HTML elements for user input, e.g. <input> or <select>. They may also contain custom input components found at src/resources/views/components/inputs
                - Modifying these inputs and/or hitting a "submit" button will result in a custom event being dispatched to the data bridge, indicating we need to fetch new data for a specific "Synchronous Group" or an independent display component (Synchronous Group of size 1).
                - Synchronous Group: A collection of display components that logically update together based on the same user input filters.
                - There are two main layouts for a User Input component. Either custom events are triggered on change of the input elements and are sent as soon as a change is made, or there is a "submit" button that sends the state of the neccessary input elements.
                - Usually there is just one User Input Component, but there can be mutliple depending on the page. One User Input Component can be responsible for multiple Synchronous Groups. 
                - A User Input component will send out one singular event for each unique synchronous group.
                - Sometimes, a User Input Component will be a child of a display component. When this is the case we will still define the user input component in its own file and will use a slot for the user input component within the display component.

                Data-Bridge Component: A "headless" (non-visual) Blade component listens for custom events from the User Input Component.
                    - The Data-Bridge component is the single source of truth for the state of an asynchronous data request. It is responsible for telling dynamic display components not only when data has arrived or a fetch error has occurred, but also when a request has started.

                    Its responsibilities are to:
                    - Receive an event from the User Input Component.
                    - Send a single POST request (using the fetch API) to the controller's getData() method for that specific synchronous group event.
                    - Receive the response from the controller.
                        - The controller should ALWAYS return a 200 OK status, even if specific components (or even all of them) failed to generate data.
                        - The response payload is an associative array where keys are component names and values are `ApiResponse` objects containing `{ data: mixed, errors: mixed }`. Either data will be valid and errors will be null, or vice versa. NEVER will they both have null or something.
                    - Dispatch the received data or errors to dynamic Display Components using a clear, three-event system:
                        - [feature]-data-loading: The data-bridge MUST dispatch this event synchronously immediately after receiving a request to fetch data, and before the await fetch() call. This signals all listening display components to enter their loading state (e.g., show a skeleton loader).
                        - [feature]-data-updated: Upon a successful fetch response (HTTP 200), the data-bridge MUST dispatch this event with the **entire** returned associative array as the payload.
                        - [feature]-fetch-error: If the fetch fails at the network level (non-200 status or network timeout), the data-bridge MUST dispatch this event with an error message in the payload.

                Display Components: These are "dumb" components that listen for events and data from the data-bridge or the initial load.
                    - There are two main types of display components, static and dynamic.
                    - static display components never need to be updated after initial page load, so they will recieve their data as props from the initial page load and will not be connnected to the databridge.
                    - dynamic display components change as data is loaded from the data-bridge. They are NEVER pre-loaded on initial load. We always get the data from the data bridge. Initial load data is triggered by a manual firing of a user input event.

                    general display component rules:
                        - Display Components MUST have a visual state for each of these three conditions: a loading state (e.g., skeleton), a data-display state, and an error state.
                        - In some cases, the Error state for a component can be a separate modal div.
                        - The init() method of a display component SHOULD set isLoading to true to handle the initial page load, ensuring a loading skeleton is shown while the very first fetch is in progress.

                    static display component rules:
                        - Still need a loading state even though it will only show briefly on initial page load.

                    dynamic display component rules:
                        - Upon receiving a [feature]-data-loading event, they display a loading skeleton.
                        - Upon receiving a [feature]-data-updated event:
                            - The component must extract its specific data from the payload using its component name key.
                            - It must check the `ApiResponse` structure:
                                - If `errors` is not null, the component updates its own state and appearance to the error state using the provided error message.
                                - If `errors` is null and `data` is present, the component updates its own state and appearance with the new data.
                        - Upon receiving a [feature]-fetch-error event, they update their own state and appearance with the global error message.
                        - Display components do not come preloaded with default data, but rather, rely on a manual firing of an event from the User Input Component at the end of its init function after the default values for the User Input Component have been set.

                        Example dynamic display component Event Flow:
                            1) User clicks a filter in the User Input Component, which dispatches a custom event called [feature]-change.
                            2) Data-bridge catches [feature]-change.
                            3) Data-bridge immediately dispatches [feature]-data-loading.
                            4) All dynamic display components listening for events from the data bridge catch [feature]-data-loading and show their skeletons.
                            5) The fetch request completes (should be with a 200 OK).
                            6) Data-bridge dispatches either [feature]-data-updated (containing individual success/failures) or [feature]-fetch-error (network fail).
                            7) All display components catch the final event.
                                - If [feature]-data-updated: Each component checks its specific `ApiResponse` key. If successful, it hides the skeleton and shows content. If that specific component failed, it shows its error state.
                                - If [feature]-fetch-error: All components hide skeletons and show their error state.

        Controller Specific Rules:
            The functions within a controller must be organized in the following order:
                1) index(): This is always the first function. It is called by a GET request to handle the initial page load. It retrieves all necessary data for the initial view and returns the view with that data. This function's internals are wrapped in a try-catch block, and if there is an error, we return a 500 error page with a custom error message, as an error here is critical.
                2) Index Helper Functions: Any functions called by index() should be placed directly below it, in the order they are called.
                3) getData(): This function is placed below all index() related functions. It is called by fetch requests from the frontend to retrieve new data based on user interactions.
                    - Note for getData: As stated in the general section, usually, there will be just one getData function per "Synchronous Group" of display components.
                    - Structure of getData(): To support partial success and isolated failures, the getData function must follow a specific "Global Context, Local Execution" pattern consisting of three stages:
                    - Stage 1 (Global Validation): Validate inputs and parse the variables recieved in the request to be used by later functions. If this fails, we return a global error payload (Every display component in the return associative array has an ApiResponse Error Object, explained below).
                    - Stage 2 (Shared Data Gathering): Perform expensive queries (e.g., Raw MongoDB Aggregations) that are required by multiple display components. This is wrapped in its own try-catch block. If it fails, the error is caught and logged, but execution continues so independent components can still load.
                        - If there is an error, the value for the variables set in the shared data gathering are set to an ApiResponse Error Object. Any component relying on these will check if this is the case, and if so, will set their own individual response object to the shared data gathering one, so it can relay the specific error.
                    - Stage 3 (Individual Components): Calculate and format data for each specific display component. Use helper functions (defined below getData) for complex component logic.
                    - Return Format:** The function ultimately returns a standard associative array where the keys are the component names and the values are `ApiResponse` objects (Success or Error). The HTTP status code should be 200, unless a catastrophic server failure occurs.
            Database Queries:
                - Use Raw MongoDB Aggregation Pipelines: For database queries within a getData function (usually Stage 2), raw MongoDB aggregation pipelines are required unless the query is a simple match. This is for performance reasons.
                - Date/Time Objects: When using raw aggregation pipelines, PHP DateTime or Carbon objects are not compatible. They must be converted to MongoDB UTCDateTime objects using the following format:
                    new \MongoDB\BSON\UTCDateTime($date->getTimestamp() * 1000)
                - Pipelines should be written to be as efficient as possible in terms of documents searched in order to reduce the time it takes for them to complete. For more information on this, please reference the MongoDB section of this guide.
                - When retrieving documents from MongoDB using an Eloquent model, the Laravel MongoDB driver automatically inspects the data and casts any BSON UTCDateTime fields directly into PHP Carbon objects. You should always treat these fields as Carbon objects immediately after retrieval.

            Data Processing (Server vs. Client):
                - A key principle is to balance server-side processing with minimizing data transfer size. The following rules apply:
                    - Server-Side Computations: All calculations, such as totals, averages, or other aggregations, must be performed by the server-side controller. This ensures that the client receives pre-computed values and does not have to perform these calculations itself.
                    - Eliminate Redundant Data: Avoid sending data that the client can easily derive on its own from the information already provided. For example, if the client can filter a list of data returned for one display component to get a specific subset needed for a different display component, do not send a separate, pre-filtered version of that same list. This minimizes the amount of data transferred.

                Example Scenario:
                    A payroll page returns a table of employee hours. It also has display components for:
                        - Total hours for all employees.
                        - Total overtime hours for all employees.
                        - Average billable percentage for all employee hours.
                        - A list of employees with fewer than 80 hours.

                    In this case, the controller's response would look like this using the ApiResponse wrapper:

                        $response = [
                        'tableData'     => ApiResponse::success($results),                  // from Mongo then processed
                        'totalHours'    => ApiResponse::success($totalCompanyHours),        // computed from processed $tableData
                        'totalOvertime' => ApiResponse::error("Calculation Failed"),        // Example of a specific component failure
                        'averageBillablePercentage' => ApiResponse::success($avgBillablePercentage)
                        // Notice there is no return variable here for the quick view list, as this can be directly derived from $tableData without any further computation.    
                        ];

                    The totalHours, totalOvertime, and averageBillablePercentage values are calculated in the controller because they require computation.
                    The list of employees with fewer than 80 hours is not returned as a separate variable. This list will be derived on the client side by filtering the tableData array, as no new computation is needed.

                    - When dealing with data that needs to be sorted, always sort initially in the Controller (Server) side, but know that the client may also need to do some sorting. Client sorting might need to happen for the following two reasons:
                        1) Some Display Components such as lists or tables might have mutliple columns by which you want data sorted. If this is the case, we will sort by whatever is the default view in the controller, and let the client sort when needed.
                        2) Multiple Display Components might need the same data, and have different default sorts. When this is the case, the larger/more important component will take precedence and have its default sort order sorted initially server side. An example of this is the payroll page. Both the payroll table (Primary/Main Display Component) and the pay-period-quick-list use the same data, but the payroll table default sort is alphabetical by employee name and the pay-period-quick-list default is total hours ascending. We give preference to the entire payroll table and sort alphabetically by employee name in the controller.   

            Error Handeling:
                - We do not use a single "catch-all" block that returns a 500 error for the whole request. We strictly adhere to the `ApiResponse` structure to allow partial page loads.
                - **Stage 1 (Validation) Errors:** If validation fails, we catch the exception and return a 200 OK response where *every* component key contains an `ApiResponse::error("Validation Failed")`.
                - **Stage 2 (Shared Data) Errors:** If the shared data query fails, we catch and log the error. We assign the shared variable a failure state (or null). We DO NOT return immediately. We proceed to Stage 3.
                - **Stage 3 (Component) Errors:** We wrap individual component logic in try-catch blocks.
                    - If a component relies on Shared Data from Stage 2, it must check if that data is valid. If the shared data is missing/erroring, the component throws an exception (or returns an error).
                    - The catch block for a component logs the error and returns `ApiResponse::error($msg)`.
                    Example:
                        try {
                            // Logic for specific component
                            return ApiResponse::success($data);
                        } catch (\Exception $e) {
                            Log::error('Component Calculation Error: ' . $e->getMessage());
                            return ApiResponse::error("Unable to load data");
                        }
                - **Logging:** All exceptions, whether global or local, must be logged with the stack trace and request inputs to assist debugging.

            General Controller Rules:
                - Use Carbon for all date objects in the controller. Often one of our first steps is taking date strings sent in from the data-bridge and converting them to Carbon Objects to be used.

        Primary View Implementation Rules:
            1) The primary view is responsible for defining a localized "Registry" Store. This store manages the "Dirty State" of the page (tracking unsaved changes across components) without tightly coupling the User Input component to the Display components.
            2) This store should be defined in a script tag within the @push('scripts') stack at the bottom of the primary view file.
            3) The store must include an array of checks, a registration function, and an execution function. The execution function (`isPageDirty`) should include a try-catch block to prevent a single component error from breaking the navigation logic.
                
                Example:
                @push('scripts')
                <script>
                    document.addEventListener('alpine:init', () => {
                        Alpine.store('financePayrollRegistry', {
                            checks: [],
                            
                            /**
                            * Register a callback function that returns true if dirty, false if clean.
                            */
                            registerDirtyCheck(callbackFunction) {
                                this.checks.push(callbackFunction);
                            },

                            /**
                            * Check all registered components. Returns true if ANY component is dirty.
                            */
                            isPageDirty() {
                                return this.checks.some(checkFn => {
                                    try {
                                        return checkFn();
                                    } catch (e) {
                                        console.error("Dirty check failed for a component:", e);
                                        return false; 
                                    }
                                });
                            }
                        });
                    });
                </script>
                @endpush
        
        User Input Component Implementation Rules:
            1) When defining the Alpine function for the User Input Object, the different sections should be in the following order:
                @push('scripts')
                <script>
                        function financeControlPanelLogic(dateRanges) {
                        return {
                        1)Class/Instance Variables set to null
                        2)init() {
                            2a)initialize class/instance variables
                            2b)define watchers
                            2c)
                            }
                        3)otherFunctions()
                        4)dispatchChangeEvent()
                        
                    }
                    }
                </script>
                @endpush

            2) at the end of the init function in the User Input Component, manually dispatch an initial event to load the default data for all the display components. The display components should always get their default data from an initial dispatch, and not pre-loaded from the controller somehow. 
                - This must be done using nextTick to ensure the display components are ready.
                Good example:
                    init() {
                        // Initialize Instance Variables
                        this.selectedYear = new Date().getFullYear().toString();
                        this.selectedDateRange = this.getDateRangeOptions()[0] || null;
                        this.activeFilters = ["active"]
                        this.isUpdating = false;

                        // Set up watchers //

                        // selectedYear Watcher
                        this.$watch('selectedYear', () => {
                            this.isUpdating = true;
                            const newOptions = this.getDateRangeOptions();
                            this.selectedDateRange = newOptions[0] || null;
                            this.dispatchChangeEvent();
                            this.$nextTick(() => {
                                this.isUpdating = false;
                            });
                        });

                        // selectedDateRange Watcher   
                        this.$watch('selectedDateRange', () => {
                            if (this.isUpdating) return; 

                            this.dispatchChangeEvent()
                        });
                        
                        // activeFilters Watcher 
                        this.$watch('activeFilters', () => this.dispatchChangeEvent());

                        // Fire initial dispatch event with default values
                        this.$nextTick(() => {
                            this.dispatchChangeEvent();
                        });
                    }
            3) Use a Centralized Dispatch Function for Emitting Events from the user-input component
                - All component events fired with $dispatch should be wrapped in a dedicated function, typically named dispatchChangeEvent(). This function should be responsible for structuring the event payload.
                - Bad Example:
                    // Multiple dispatch calls scattered in the code
                    this.$watch('rangeMode', () => {
                            // ... logic ...
                            this.$dispatch('finance-panel-change', {
                                timeGranularity: this.rangeMode,
                                year: this.selectedYear,
                                dateRangeDropdown: this.selectedDateRange,
                                activeFilters: this.activeFilters
                            });
                    });

                    this.$watch('activeFilters', () => {
                            // ... logic ...
                            this.$dispatch('finance-panel-change', {
                                timeGranularity: this.rangeMode,
                                year: this.selectedYear,
                                dateRangeDropdown: this.selectedDateRange,
                                activeFilters: this.activeFilters
                            });
                    });

                - Good Example:
                    // All watchers and methods call a single dispatch function
                    init() {
                            this.$watch('rangeMode', () => {
                                // ... logic ...
                                this.dispatchChangeEvent();
                            });
                    
                            this.$watch('activeFilters', () => this.dispatchChangeEvent());
                    },

                    dispatchChangeEvent() {
                            this.$dispatch('finance-panel-change', {
                                timeGranularity: this.rangeMode,
                                year: this.selectedYear,
                                dateRangeDropdown: this.selectedDateRange,
                                activeFilters: this.activeFilters
                            });
                    },

            4) Safely Manage Watcher Side Effects with State Flags
                - When a watcher ($watch) modifies a reactive property that is itself being watched, use a boolean state flag (e.g., isUpdating, isLoading) to prevent infinite loops or unintended watcher execution. This will often arise when changing state of an element inside a component changes the state of another element inside the same component, and both have watchers that send out external events. 
                - Bad Example:
                    // Bad Example - No flags, causes infinite loops and unpredictable behavior
                    init() {
                        // This watcher triggers when selectedYear changes
                        this.$watch('selectedYear', () => {
                            const newOptions = this.getDateRangeOptions();
                            this.selectedDateRange = newOptions[0] || null; // This triggers the watcher below!
                            this.dispatchChangeEvent();
                        });
                        
                        // This watcher triggers when selectedDateRange changes
                        this.$watch('selectedDateRange', () => {
                            this.dispatchChangeEvent(); // This runs even during programmatic updates
                            
                            // Even worse - if this watcher also modified selectedYear:
                            // this.selectedYear = someNewValue; // Would create an infinite loop!
                        });
                    }
                - Good Example:
                    init() {
                        this.isUpdating = false;

                        // This watcher TRIGGERS the controlled update
                        this.$watch('selectedYear', () => {
                            this.isUpdating = true; // 1. Set the flag
                            
                            const newOptions = this.getDateRangeOptions();
                            this.selectedDateRange = newOptions[0] || null; // 2. This change would normally trigger the watcher below
                            
                            this.dispatchChangeEvent();
                            
                            this.$nextTick(() => {
                                this.isUpdating = false; // 4. Reset the flag after the DOM updates
                            });
                        });

                        // This watcher RESPECTS the controlled update
                        this.$watch('selectedDateRange', () => {
                            // 3. The flag prevents this watcher's logic from running during the update
                            if (this.isUpdating) return; 

                            this.dispatchChangeEvent();
                        });
                    }
            5) Handling Unsaved Changes (Dirty State)
                - If a page requires checking for unsaved changes before loading new data, this check must be performed "Just in Time" inside the `dispatchChangeEvent` or action functions (e.g., `navigateWeek`).
                - **Do not** put the check inside getters or functions bound to `x-text` or `x-show`, as this will cause side effects (like alerts appearing) during simple re-renders.
                - Example:
                    dispatchChangeEvent() {
                        // 1. Run the registry checks synchronously
                        const isDirty = this.$store.financePayrollRegistry.isPageDirty();

                        if (isDirty) {
                            if (!confirm("You have unsaved changes. Loading new filters will discard them. Continue?")) {
                                return; // Stop the dispatch
                            }
                        }

                        // 2. Proceed with dispatch
                        this.$dispatch('finance-panel-change', { ... });
                    }
        
        Data-Bridge Implementation Rules:
            1) The data-bridge component will always use the fetch API and not AJAX.

            2) Laravel requires csrf tokens in fetch requests, so we must store them in a meta header so we can later include them in the fetch.

            3) The data-bridge component will always have a comment at the top of the file that showcases the structure of the expected data it expects to recieve from the getData endpoint in the controller.

            4) The Async function should always be called fetchData unless we need multiple (more than one synchronous group) and need to specify between them.
                - If there are mutliple, they will always exist in one data-bridge with multiple fetch abilities, rather than mutliple data-bridges.
            
            5) Syntactically (variable name and code line structure) the Data-Bridge should here as close as possible to the generalzied example below:

                {{-- Comment at the top describing structure of the data recived from the User Input Component and the structure of the data recieved from the fetch to the Controller--}}
                <div
                    x-data="dataBridge()"
                    x-on:[user-input-component-name-here]-change.window="fetchData($event)"
                    class="hidden"
                ></div>

                @push('scripts')
                <script>
                function dataBridge() {
                    return {
                        /**
                        * @param {CustomEvent} event The event dispatched from the User Input Component.
                        */
                        async fetchData(event) {
                            this.$dispatch('[feature]-data-loading');
                            const userInputVariables = event.detail;

                            try {
                                // Perform a fetch request to our API endpoint
                                const response = await fetch('/outerpath/innerpath/getdata', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Accept': 'application/json',
                                        // Laravel requires a CSRF token for POST requests
                                        'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                                    },
                                    body: JSON.stringify(userInputVariables)
                                });

                                const payload = await response.json();
                                // Dispatch a new event with the fetched data for other components
                                this.$dispatch('[feature]-data-updated', payload);

                            } catch (error) {
                                this.$dispatch('[feature]-fetch-error', error.message);
                            }
                        }
                    }
                }
                </script>
                @endpush
        
        Display Component:
            1)The functions in the display components alpine object that handle loading and errors should be the last two functions in the display component's functions, in that order (update function, then error function)
    
            2) For display components, the listeners to the dispatch events should be defined in the order loading, data, and error, and should be on separate lines
                Good Example:
                    <div x-data="PPQuickListLogic()" 
                        @payroll-data-loading.window="handlePayrollFetchInitiated($event)"
                        @payroll-data-updated.window="handlePayrollDataUpdate($event)"
                        @payroll-fetch-error.window="handlePayrollFetchError($event)"
                        ...
                    </div>
            3) As a reminder, there are two types of errors a display component could recieve. It could reicieve an ApiResponse Object with errors instead of data, or there could be some sort of network error, which would trigger the data-bridge to send out a custom event called [feature]-fetch-error.
                - To Handle this, there will be two functions, both of which will result in the display components error state being displayed.
                - There will be a generall function called "handleError(errorMessage) which will handle all the logic for handeling the error and having the display component show its error state. Here is an example of it being called:
                handlePayrollDataUpdate(event) {    
                    // 1. Extract the specific payload for THIS component
                    const responseObj = event.detail.tableData;

                    // Safety check: if controller didn't return this key for some reason
                    if (!responseObj) {
                        this.handleError("Invalid response format");
                        return;
                    }

                    // 2. Check for Component-Specific Error (ApiResponse::error)
                    if (responseObj.errors) {
                        this.handleError(responseObj.errors);
                        return;
                    }
                }
                    ...
                    
                handleError(errorMessage) {
                    this.error = errorMessage
                    this.tableData = [];
                    this.summaryRows = [];
                    this.isLoading = false;
                },
                ...

                There will also then be the function called that is listening for the [feature]-fetch-error and this will get the message from the event and then call handleError(errorMessage):
                
                handlePayrollFetchError(event) {
                    const errorMessage = event.detail;
                    this.handleError(errorMessage);
                },
            
            4) Registering Dirty State Checks:
                - If a display component allows user modification that could be saved to the backend, it must register a callback function with the local Alpine registry store inside its `init()` method.
                - This callback should return `true` if the component has unsaved changes and `false` otherwise.
                Example:
                    init() {
                        // ... other init logic ...
                        2a:
                        2b:
                        // Register dirty check using arrow function to preserve 'this' context
                        new 2c: this.$store.financePayrollRegistry.registerDirtyCheck(() => this.hasUnsavedChanges());
                    },
                    
                    hasUnsavedChanges() {
                        if (this.isLoading) return false;
                        return JSON.stringify(this.rows) !== JSON.stringify(this.pristineRows);
                    },

        General Alpine Rules:
            1) Do not define the Alpine object within the x-data, but instead, define it in a separate script tag at the bottom of the component file. The name of the function called should be the CamelCase path to the component file followed by the word "Logic". See the example below for the user input component of the payroll page for the finance team:
            
            <div x-data='financePayrollControlPanelLogic(@json($phpVarFromProps))'>
                ...
            </div>

            @push('scripts')
            <script>
                    function financePayrollCOntrolPanelLogic(dateRanges) {
                    return {
                    <Alpine Object vars and functions here>
                }
                }
            </script>
            @endpush

            2) Always use the full x-bind:attribute="<some JavaScript Expression here>" instead of :attribute="<some JavaScript Expression here>"
                - this is because In Laravel, we use the ":" character to pass PHP expressions to Blade Components as props, and having them both in there can feel confusing

            3) Always set any class/instance variables for the alpine object to null and then initialize them in the first part of the init() function
                Example:
                    function financePayrollControlPanelLogic(dateRanges) {
                        return {
                            selectedYear:  null,
                            selectedDateRange: null,
                            activeFilters: null,
                            isUpdating: null,

                            init() {
                                // Initialize Instance Variables
                                this.selectedYear = new Date().getFullYear().toString();
                                this.selectedDateRange = this.getDateRangeOptions()[0] || null;
                                this.activeFilters = ["active"]
                                this.isUpdating = false;
                                ...
                            }
                        }
                    }
            4) When you are conditionally setting the TailWind classes of an html element using x-bind:class="", if possible use the ternary, operator. If not, use Object Syntax:
                - Example if ternary possible:
                    x-bind:class="activeFilters.includes(filter) ? 'bg-slate-700 text-white font-semibold' : 'bg-slate-200 text-slate-600 hover:bg-slate-300'"

                -Example if not possible:
                    x-bind:class="{
                        'bg-green-500 text-white': status === 'success',
                        'bg-yellow-500 text-black': status === 'warning', 
                        'bg-red-500 text-white': status === 'error',
                        'bg-gray-500 text-white': status === 'pending'
                        }"
            5) When using <template> elements inside x-for blocks, if what is being populated needs to dynamically change, try to use just one template chunk with a function instead of multiple
                - Bad Example:
                    <select class="col-span-3 w-full bg-slate-50 border">
                        <template x-if="rangeMode === 'month'">
                            <template x-for="month in monthsForSelectedYear" :key="month">
                                <option x-bind:value="month" x-text="month"></option>
                            </template>
                        </template>
                        <template x-if="rangeMode === 'payPeriod'">
                            <template x-for="pp in payPeriodsForSelectedYear" :key="pp">
                                <option x-bind:value="pp" x-text="pp"></option>
                            </template>
                        </template>
                    </select>
                    ...
                    <script>
                        function financePayrollControlPanelLogic(dateRanges) {
                        return {
                            selectedYear: null,
                            rangeMode: null,

                            init() {
                                this.selectedYear = new Date().getFullYear().toString();
                                this.rangeMode = "payPeriod";
                            },
                            getPayPeriodsForSelectedYear() {
                                return dateRanges[this.selectedYear]?.payPeriods || [];
                            },

                            getMonthsForSelectedYear() {
                                return dateRanges[this.selectedYear]?.months || [];
                            }
                        }
                        }
                    <script>
                
                - Good Example:
                    <select class="col-span-3 w-full bg-slate-50 border">
                        <template x-for="option in getDateRangeOptions()" :key="option">
                            <option x-bind:value="option" x-text="option"></option>
                        </template>
                    </select>
                    ...
                    <script>
                        function financePayrollControlPanelLogic(dateRanges) {
                        return {
                            selectedYear: null,
                            rangeMode: null,

                            init() {
                                this.selectedYear = new Date().getFullYear().toString();
                                this.rangeMode = "payPeriod";
                            },

                            getDateRangeOptions() {
                                if (this.rangeMode === 'month')
                                    return dateRanges[this.selectedYear]?.months || [];

                                else if (this.rangeMode === 'payPeriod')
                                    return dateRanges[this.selectedYear]?.payPeriods || [];
                            },
                        }
                        }
                    <script>

            6) When calling a function defined in the Alpine Object, always call it with the "()" at the end of the function name to signify it is a function. This also means that we do NOT use the "get" keyword to name a getter function.
                - Bad Example:
                    <select class="col-span-3 w-full bg-slate-50 border">
                        <template x-for="option in dateRangeOptions" :key="option"> 
                            <option x-bind:value="option" x-text="option"></option>
                        </template>
                    </select>
                    ...
                    <script>
                        function financePayrollControlPanelLogic(dateRanges) {
                        return {
                            selectedYear: null,
                            rangeMode: null,

                            init() {
                                this.selectedYear = new Date().getFullYear().toString();
                                this.rangeMode = "payPeriod";
                            },

                            get dateRangeOptions() {
                                if (this.rangeMode === 'month')
                                    return dateRanges[this.selectedYear]?.months || [];

                                else if (this.rangeMode === 'payPeriod')
                                    return dateRanges[this.selectedYear]?.payPeriods || [];
                            },
                        }
                        }
                    <script>

                - Good Example:
                    <select class="col-span-3 w-full bg-slate-50 border">
                        <template x-for="option in getDateRangeOptions()" :key="option"> 
                            <option x-bind:value="option" x-text="option"></option>
                        </template>
                    </select>
                    ...
                    <script>
                        function financePayrollControlPanelLogic(dateRanges) {
                        return {
                            selectedYear: null,
                            rangeMode: null,

                            init() {
                                this.selectedYear = new Date().getFullYear().toString();
                                this.rangeMode = "payPeriod";
                            },

                            getDateRangeOptions() {
                                if (this.rangeMode === 'month')
                                    return dateRanges[this.selectedYear]?.months || [];

                                else if (this.rangeMode === 'payPeriod')
                                    return dateRanges[this.selectedYear]?.payPeriods || [];
                            },
                        }
                        }
                    <script>

            7) Pass Server-Side Data Securely with @json for the initial load
                - Always use the @json Blade directive to pass PHP variables (especially arrays and objects) into your Alpine component's data for the initial load. These variables will almost always be coming from the parent blade view, passed in via props, that is instantiating the component. The parent blade view got the variable from the Controller


Database (MongoDB) rules and structure:

    Our database has the following main collections:
        users,
        projects,
        sub-projects,
        hours,
        pinned_projects,
        globals

    Each collection has an eloquent model in Laravel found under App/Models/
    We will dive into each one in detail below.

    users collection:
        description: Every document represents one employee
        name: users
        eloquent model name: User
        current number of documents: ~150
        documents added per day: <1
        documents added per week: <1
        documents added per month: ~1
        documents added per fisacal quarter: ~3
        documents added per year: ~12

        document structure:
        {
            "_id": {
                "$oid": <Object ID>
            },
            "name": <String> Usually First and Last, but some people have multiple last names,
            "email": <String>,
            "password": <String>",
            "role": <String>,
            "updated_at": {
                "$date": <MongoDB UTC Date String>
            },
            "created_at": {
                "$date": <MongoDB UTC Date String>
            },
            "remember_token": <String>,
            "email_verified_at": {
                "$date": <MongoDB UTC Date String>
            },
            "active": Boolean,
            "nickname": String,
            "perhourdollar": Int32,
            "hour_rates": {
                "<Year String>": Int32,
                ...
            },
            "owner": Boolean,
            "employee_number": Int32,
            "wage_type": <String> either "Salaried" or "Hourly",
            "spreadsheet_name": <String>,
            "end_date": Either the string "N/A" if still active or a  <MongoDB UTC Date String> if they have left
            "start_date": {
                "$date":  <MongoDB UTC Date String>
            },
            "jobclass": <String>,
            "expected_billable": <Boolean>
        }

        foreign keys and cross references:
            email => hours collection's "user_email"

        indexes:
            _id,
            email


    projects collection:
        description: Every document represents one project at the company. Every project has at least one or more sub-project. This can be identified via strings in the sub-projects array that match projectname field in the sub-projects collection along with the same projectcode value. There are some projects of interest to keep in mind. Any project that has is_internal set to true is not billable. 
        name: projects
        eloquent model name: Project
        current number of documents: ~850
        documents added per day: <1
        documents added per week: ~2
        documents added per month: ~8
        documents added per fiscal quarter: ~25
        documents added per year: ~100

        document structure:
        {
            "_id": {
                "$oid": <Object ID>
                },
            "projectcode": <String>,
            "projectname": <String>,
            "datentp": {
                "$date": <MongoDB UTC Date String>
            },
            "dateenergization": {
                "$date": <MongoDB UTC Date String>
            },
            "dollarvalueinhouse": <Double>,
            "projectmanager": <String>,
            "projectstatus": <String>,
            "sitelocation": <String>,
            "billingmethod": <String>,
            "clientcompany": <String>,
            "clientcontactname": <String>,
            "dateproposed": {
                "$date": <MongoDB UTC Date String>
            },
            "country": <String>,
            "state": <String>,
            "utility": <String>,
            "voltage": <String>,
            "mwsize": <String>,
            "updated_at": {
                "$date": <MongoDB UTC Date String>
            },
            "created_at": {
                "$date": <MongoDB UTC Date String>
            },
            "sub-projects": <Array<String>>
            "ongoing": Boolean,
            "projecttype": <Array<String>>,
            "is_internal" <Boolean>
        }

        foreign keys and cross references:
            projectcode => hours collection's "project_code"
            projectcode => sub-projects collection's "projectcode"
            sub-projects => Strings in this array match "projectname" value for a sub-project document. This, along with needing the projectcode, can be used to identify a sub-project in the sub-projects collection.

        indexes:
            _id

    sub-projects collection:
        description: Every document in this collection represents a sub-project. sub-project names are not unique, so they must be paired with the parent "projectcode" to be unique. Special sub-projects of note, if the projectcode is "CEG" and the sub-project projectname is within the 200 codes global document, then it represents a 200 code, meaning excused time off 
        name: sub-projects
        eloquent model name: SubProject
        current number of documents: ~1000
        documents added per day: ~1
        documents added per week: ~7
        documents added per month: ~30
        documents added per fiscal quarter: ~90
        documents added per year: ~ 300

        document structure:
        {
            "_id": {
                "$oid": <Object ID>
                },
            "projectcode": <String>,
            "projectname": <String>,
            "activity_codes": <Array<String>>,
            "datentp": {
                "$date": <MongoDB UTC Date String>
            },
            "dateenergization": {
                "$date": <MongoDB UTC Date String>
            },
            "dollarvalueinhouse": <Double>,
            "projectmanager": <String>,
            "projectstatus": <String>,
            "sitelocation": <String>,
            "billingmethod": <String>,
            "clientcompany": <String>,
            "clientcontactname": <String>,
            "dateproposed": {
                "$date": <MongoDB UTC Date String>
            },
            "country": <String>,
            "state": <String>,
            "utility": <String>,
            "voltage": <String>,
            "mwsize": <String>,
            "updated_at": {
                "$date": <MongoDB UTC Date String>
            },
            "created_at": {
                "$date": <MongoDB UTC Date String>
            },
            "is_billable": <Boolean>,
            "ongoing": Boolean,
            "projecttype": <Array<String>>
        }

        foreign keys and cross references:
                projectcode => hours collection's "project_code"
                projectcode => projects collection's projectcode"
                projectname => hours collection's "sub_project"
                projectname => match a string in the parent project's sub-projects array

            indexes:
                _id,

    hours collection:
        description: The hours collection holds one document for every timesheet entry for one employee. 
        name: hours
        eloquent model name: Hour
        current number of documents: ~250,000
        documents added per day: ~180
        documents added per week: ~1,250
        documents added per month: ~5,500
        documents added per fiscal quarter: ~ 16,500
        documents added per year: ~70,000

        document structure:
            {
                "_id": {
                    "$oid": <Object ID>
                },
                "project_code": <String>,
                "sub_project": <String>,
                "activity_code": <String>,
                "date": {
                    "$date": <MongoDB UTC Date String>
                },
                "user_email": <String>,
                "hours": <Double>,
                "updated_at": {
                    "$date": <MongoDB UTC Date String>
                }
            }
        
        foreign keys and cross references:
            user_email => users collection's "email"
            project_code => projects collection's "projectcode"
            sub_project => a string value in the array for the value of the "sub-projects" field in the "projects" collection. Note this one is not unique so cannot actually be used as a foreign key, but is unique if you include the project code. 
            sub_project => sub-projects collection's "projectname". Note this one is not guarenteed to be unique so cannot actually be used as a foreign key, but is unique if you include the project code. 

        indexes:
            _id,
            date->project_code->user_email,
            date->user_email->project_code,
            user_email->date->project_code,
            user_email->project_code->date,
            project_code->date->user_email

    pinned_projects:
        description: Every document represents a unique project_code, sub_project, activity_code combo that a specific user has pinned in their timesheet. 
        name: pinned_projects
        eloquent model name: PinnedProject
        current number of documents: ~500
        documents added per day: ~0-1
        documents added per week: ~2-5
        documents added per month: ~5-15
        documents added per fiscal quarter: ~ 15-45
        documents added per year: ~ 50-100

        document structure:
        {
            "_id": {
                "$oid": <Object ID>
            },
            "user_email": <String>,
            "project_code": <String>,
            "sub_project": <String>,
            "activity_code": <String>,
        }

        foreign keys and cross references:
            user_email => users collection's "email"
            user_email => hours collection's "user_email"
            project_code => projects collection's "projectcode"
            sub_project => a string value in the array for the value of the "sub-projects" field in the "projects" collection. Note this one is not unique so cannot actually be used as a foreign key, but is unique if you include the project code.

        indexes:
            none
            sub_project => sub-projects collection's "projectname" Note this one is not guarenteed to be unique so cannot actually be used as a foreign key, but is unique if you include the project code. 
    globals collection:
        description: This is not like the other collections that all hold many documents of the same schema. This collection holds one-off documents that hold useful information across the website that is consistently referenced. We will just include all the documents below for reference:
        name: globals
        eloquent model name: Global:

        documents:
        [
        {
        "_id": {
            "$oid": "671bf5efe138f9e74264c2c3"
        },
        "name": "activity_codes",
        "general": [
            "General",
            "Drawing",
            "Studies",
            "Project Manangement",
            "Research and Development",
            "Travel",
            "Construction Support in Office",
            "Construction Support in Field",
            "Procurement",
            "Administrative",
            "Billing",
            "Warranty"
        ],
        "drawing": [
            "Drawing - Title Sheet",
            "Drawing - Plot Plan",
            "Drawing - Schedule",
            "Drawing - Oneline",
            "Drawing - Schematic Diagram",
            "Drawing - Communication Architecture",
            "Drawing - Trench",
            "Drawing - Elevation",
            "Drawing - Grounding"
        ],
        "studies": [
            "Study - Ampacity",
            "Study - Arc Flash",
            "Study - Dispatch/Degredation",
            "Study - Fault Current",
            "Study - Grounding",
            "Study - Power Flow",
            "Study - Reactive",
            "Study - Relay and Coordination",
            "Study - Sound"
        ]
        },
        {
        "_id": {
            "$oid": "671bffbd58244d4a53dd7bf6"
        },
        "name": "project_types",
        "types": [
            "Solar",
            "Wind",
            "Substation",
            "SCADA",
            "BESS",
            "Support",
            "Transmission",
            "Other"
        ]
        },
        {
        "_id": {
            "$oid": "671bffbd58244d4a53dd7bf7"
        },
        "name": "countries_list",
        "countries": [
            "Afghanistan",
            ...
            "Zimbabwe"
        ]
        },
        {
        "_id": {
            "$oid": "671bffbd58244d4a53dd7bf8"
        },
        "name": "US_states_and_territories_list",
        "states_and_territories": [
            "Alabama",
            ...
            "Wyoming"
        ]
        },
        {
        "_id": {
            "$oid": "672121f1ba4d4a49a4de3009"
        },
        "name": "billing_methods_list",
        "billing_methods": [
            "Time and Materials",
            "Schedule of Values",
            "Lump Sum"
        ]
        },
        {
        "_id": {
            "$oid": "672122e303bc70a2fb6036e4"
        },
        "name": "project_statuses_list",
        "project_statuses": [
            "Won",
            "Done and Billing Complete",
            "Expired",
            "Proposed",
            "Probable"
        ]
        },
        {
        "_id": {
            "$oid": "674656994ca3cfe724b038c6"
        },
        "name": "proposal_statuses_list",
        "proposal_statuses": [
            "Proposed",
            "Probable"
        ]
        },
        {
        "_id": {
            "$oid": "6750b511c64f3acd19ba9e0b"
        },
        "name": "Pay-Periods",
        "Pay-Periods": {
            "2018": [
            {
                "start_date": {
                "$date": "2018-01-01T00:00:00.000Z"
                },
                "end_date": {
                "$date": "2018-01-13T23:59:59.999Z"
                }
            },
            ...
            {
                "start_date": {
                "$date": "2018-12-30T00:00:00.000Z"
                },
                "end_date": {
                "$date": "2018-12-31T23:59:59.999Z"
                }
            }
            ],
            "2019": [
            {
                "start_date": {
                "$date": "2019-01-01T00:00:00.000Z"
                },
                "end_date": {
                "$date": "2019-01-12T23:59:59.999Z"
                }
            },
            ...
            ]
        }
        },
        {
        "_id": {
            "$oid": "6750b67ec64f3acd19bab8a8"
        },
        "name": "Fiscal-Quarters",
        "Fiscal-Quarters": {
            "2018": {
            "Q1": {
                "start_date": {
                "$date": "2018-01-01T00:00:00.000Z"
                },
                "end_date": {
                "$date": "2018-03-31T23:59:59.999Z"
                }
            },
            "Q2": {
                "start_date": {
                "$date": "2018-04-01T00:00:00.000Z"
                },
                "end_date": {
                "$date": "2018-06-30T23:59:59.999Z"
                }
            },
            "Q3": {
                "start_date": {
                "$date": "2018-07-01T00:00:00.000Z"
                },
                "end_date": {
                "$date": "2018-09-30T23:59:59.999Z"
                }
            },
            "Q4": {
                "start_date": {
                "$date": "2018-10-01T00:00:00.000Z"
                },
                "end_date": {
                "$date": "2018-12-31T23:59:59.999Z"
                }
            }
            },
            "2019": {
            "Q1": {
                "start_date": {
                "$date": "2019-01-01T00:00:00.000Z"
                },
                "end_date": {
                "$date": "2019-03-31T23:59:59.999Z"
                }
            }
            ...
        }
        },
        {
        "_id": {
            "$oid": "6787dc7bb4191483d9c17b83"
        },
        "name": "clients_to_abbreviations",
        "mapping": {
            "Adapture": "ADPT",
            "Aid Electric": "SMA",
            "Akuo Energy": "AK",
            "Apex": "APEX",
            "Aspenall": "ASP",
            "BayWa": "BAY",
            ...
            "Ziegler Power Systems": "ZPS"
        }
        },
        {
        "_id": {
            "$oid": "6787dcea2fea780e0a906746"
        },
        "name": "CEG_clients_list",
        "clients": [
            "Adapture",
            "Aid Electric",
            "Akuo Energy",
            "Apex",
            "Aspenall",
            ...
            "Ziegler Power Systems"
        ]
        },
        {
        "_id": {
            "$oid": "6883b4b3e226e2687ef9ce7a"
        },
        "name": "200_codes", // Excused Time off codes. projectcode must be "CEG"
        "200_codes": [
            "Parental Leave",
            "Jury Duty",
            "Funeral",
            "FMLA"
        ]
        }]
    

    Aggregation Pipeline Guideline:
        - As stated in the Controller section, we will almost always use raw MongoDB aggregation pipelines for getting data inside a controller. The only exception to this is when the query is a simple match query.
        - We need to take extra precaution to be as efficient as possible when writing these pipelines. We need to be smart about our match query, the order in which we group documents, and trying to reduce the amount of documents we need to lookup (Left Outer Join). To do this, we must take into account the size of the collections we are dealing with and how many documents we should expect after each matching stage. This data can be found/inferred based on the number of documents info in each collection.
        - We will showcase an example of paying attention to the efficiency below:

            Scenario: We need to aggregate hours data per employee for a certain range of time.
            Bad example: In this example, we can expect around 5500 documents returned from the match stage. We know this because the maximum date range for this particular usecase is a month, and there are around 5500 documents per month in the hours collection based on the data provided in this MongoDB guide. We then perform 5500 lookups to the user collection, despite there only being around 150 users. This is hugely inefficient. We should group by user first to reduce the amount of lookups by >90%. For reference, this query took 600ms when exectued.

                $pipeline = [
                    // Stage 1: Match hours within the date range
                    [
                        '$match' => [
                            'date' => [
                                '$gte' => new \MongoDB\BSON\UTCDateTime($startDate->getTimestamp() * 1000),
                                '$lte' => new \MongoDB\BSON\UTCDateTime($endDate->getTimestamp() * 1000),
                            ],
                        ],
                    ],
                    // Stage 2: Lookup users. Notice we should expect around 5500 documents returned from stage 1, and now we will execute 5500 look-ups! This is bad!
                    [
                        '$lookup' => [
                            'from' => 'users',
                            'localField' => 'user_email',
                            'foreignField' => 'email',
                            'as' => 'user',
                        ],
                    ],
                    // Stage 3: Deconstruct the user array
                    [
                        '$unwind' => '$user',
                    ],
                    // Stage 4: Apply user filters if any
                    ($userMatchFilter) ? ['$match' => $userMatchFilter] : null,
                    // ---------------------------------------------
                    // Stage 5: Group by employee to calculate hours
                    [
                        '$group' => [
                            '_id' => [
                                'employee_id' => '$user.employee_number',
                                'name' => '$user.name',
                            ],
                            'expected_billable' => ['$first' => '$user.expected_billable'], 
                            'pto' => [
                                '$sum' => [
                                    '$cond' => [
                                        'if' => [
                                            '$and' => [
                                                ['$eq' => ['$project_code', 'CEG']],
                                                ['$eq' => ['$sub_project', 'PTO']],
                                            ],
                                        ],
                                        'then' => '$hours',
                                        'else' => 0,
                                    ],
                                ],
                            ],
                            'holiday' => [
                                '$sum' => [
                                    '$cond' => [
                                        'if' => [
                                            '$and' => [
                                                ['$eq' => ['$project_code', 'CEG']],
                                                ['$eq' => ['$sub_project', 'Holiday']],
                                            ],
                                        ],
                                        'then' => '$hours',
                                        'else' => 0,
                                    ],
                                ],
                            ],
                            'other_200' => [
                                '$sum' => [
                                    '$cond' => [
                                        'if' => [
                                            '$and' => [
                                                ['$eq' => ['$project_code', 'CEG']],
                                                ['$in' => ['$sub_project', $codes_200]],
                                                ['$ne' => ['$sub_project', 'PTO']],
                                                ['$ne' => ['$sub_project', 'Holiday']],
                                            ],
                                        ],
                                        'then' => '$hours',
                                        'else' => 0,
                                    ],
                                ],
                            ],
                            'other_nb' => [
                                '$sum' => [
                                    '$cond' => [
                                        'if' => [
                                            '$and' => [
                                                // Condition 1: Must be an internal project.
                                                ['$in' => ['$project_code', $internalProjectCodes]],
                                                // Condition 2: And it must NOT be one of the specific CEG categories
                                                // that are already being calculated separately.
                                                ['$or' => [
                                                    // It's an internal project other than CEG.
                                                    ['$ne' => ['$project_code', 'CEG']],
                                                    // Or it IS CEG, but its sub-project is not one of the special cases.
                                                    ['$and' => [
                                                        ['$eq' => ['$project_code', 'CEG']],
                                                        ['$not' => ['$in' => ['$sub_project', $allSpecialCEGSubProjects]]]
                                                    ]]
                                                ]]
                                            ]
                                        ],
                                        'then' => '$hours',
                                        'else' => 0,
                                    ],
                                ],
                            ],
                            'billable' => [
                                '$sum' => [
                                    '$cond' => [
                                        'if' => [
                                            '$and' => [
                                                ['$ne' => ['$project_code', 'CEG']],
                                                ['$not' => ['$in' => ['$project_code', $internalProjectCodes]]],
                                            ],
                                        ],
                                        'then' => '$hours',
                                        'else' => 0,
                                    ],
                                ],
                            ],
                            'total_hours' => ['$sum' => '$hours'],
                        ],
                    ],
                    // Stage 6: Project the final structure
                    [
                        '$project' => [
                            '_id' => 0,
                            'employee_name' => '$_id.name',
                            'employee_id' => '$_id.employee_id',
                            'expected_billable' => '$expected_billable',
                            'pto' => '$pto',
                            'holiday' => '$holiday',
                            'other_200' => '$other_200',
                            'other_nb' => '$other_nb',
                            'total_nb' => [
                                '$add' => ['$pto', '$holiday', '$other_200', '$other_nb'],
                            ],
                            'billable' => '$billable',
                            'total_hours' => '$total_hours',
                            'billable_percentage' => [
                                '$cond' => [
                                    'if' => ['$gt' => ['$total_hours', 0]],
                                    'then' => [
                                        '$multiply' => [['$divide' => ['$billable', '$total_hours']], 100],
                                    ],
                                    'else' => 0,
                                ],
                            ],
                            'overtime' => [
                                '$cond' => [
                                    'if' => ['$gt' => ['$total_hours', 80]],
                                    'then' => ['$subtract' => ['$total_hours', 80]],
                                    'else' => 0,
                                ],
                            ],
                        ],
                    ],
                    // Stage 7: Sort the results by employee name
                    [
                        '$sort' => [
                            'employee_name' => 1
                        ]
                    ]
                ];

            Good Example: Notice now we group by employee to drastically reduce the number of lookups we need to do. This reduced our actual execution time from 600ms to 42ms.
                 $pipeline = [
                    // Stage 1: Match hours within the date range (Unchanged)
                    [
                        '$match' => [
                            'date' => [
                                '$gte' => new \MongoDB\BSON\UTCDateTime($startDate->getTimestamp() * 1000),
                                '$lte' => new \MongoDB\BSON\UTCDateTime($endDate->getTimestamp() * 1000),
                            ],
                        ],
                    ],

                    // Stage 2: [NEW] Pre-group by user email to reduce lookup operations
                    [
                        '$group' => [
                            '_id' => '$user_email',
                            // Store all related hour documents in an array for later processing
                            'hours_entries' => ['$push' => '$$ROOT'],
                        ],
                    ],

                    // Stage 3: [NEW] Perform the lookup on the much smaller, grouped dataset
                    [
                        '$lookup' => [
                            'from' => 'users',
                            'localField' => '_id', // Join on the grouped user_email
                            'foreignField' => 'email',
                            'as' => 'userInfo', // Use a new name to avoid conflicts
                        ],
                    ],

                    // Stage 4: [NEW] Deconstruct the userInfo array
                    [
                        '$unwind' => '$userInfo',
                    ],

                    // Stage 5: [MOVED & MODIFIED] Apply user filters *after* the lookup
                    // IMPORTANT: Your filter logic must now reference the 'userInfo' object.
                    // e.g., 'user.active' becomes 'userInfo.active'
                    ($userMatchFilter) ? ['$match' => $userMatchFilter] : null,

                    // Stage 6: [NEW] Deconstruct the hours_entries array to process each entry
                    [
                        '$unwind' => '$hours_entries',
                    ],

                    // Stage 7: [MODIFIED] Final grouping for calculations. All field paths are updated.
                    [
                        '$group' => [
                            '_id' => [
                                'employee_id' => '$userInfo.employee_number', // Path updated
                                'name' => '$userInfo.name',                   // Path updated
                            ],
                            'expected_billable' => ['$first' => '$userInfo.expected_billable'], // Path updated
                            'pto' => [
                                '$sum' => [
                                    '$cond' => [
                                        'if' => [
                                            '$and' => [
                                                // Paths updated to look inside 'hours_entries'
                                                ['$eq' => ['$hours_entries.project_code', 'CEG']],
                                                ['$eq' => ['$hours_entries.sub_project', 'PTO']],
                                            ],
                                        ],
                                        'then' => '$hours_entries.hours', // Path updated
                                        'else' => 0,
                                    ],
                                ],
                            ],
                            'holiday' => [
                                '$sum' => [
                                    '$cond' => [
                                        'if' => [
                                            '$and' => [
                                                ['$eq' => ['$hours_entries.project_code', 'CEG']],
                                                ['$eq' => ['$hours_entries.sub_project', 'Holiday']],
                                            ],
                                        ],
                                        'then' => '$hours_entries.hours', // Path updated
                                        'else' => 0,
                                    ],
                                ],
                            ],
                            'other_200' => [
                                '$sum' => [
                                    '$cond' => [
                                        'if' => [
                                            '$and' => [
                                                ['$eq' => ['$hours_entries.project_code', 'CEG']],
                                                ['$in' => ['$hours_entries.sub_project', $codes_200]],
                                                ['$ne' => ['$hours_entries.sub_project', 'PTO']],
                                                ['$ne' => ['$hours_entries.sub_project', 'Holiday']],
                                            ],
                                        ],
                                        'then' => '$hours_entries.hours', // Path updated
                                        'else' => 0,
                                    ],
                                ],
                            ],
                            'other_nb' => [
                                '$sum' => [
                                    '$cond' => [
                                        'if' => [
                                            '$and' => [
                                                ['$in' => ['$hours_entries.project_code', $internalProjectCodes]],
                                                ['$or' => [
                                                    ['$ne' => ['$hours_entries.project_code', 'CEG']],
                                                    ['$and' => [
                                                        ['$eq' => ['$hours_entries.project_code', 'CEG']],
                                                        ['$not' => ['$in' => ['$hours_entries.sub_project', $allSpecialCEGSubProjects]]]
                                                    ]]
                                                ]]
                                            ]
                                        ],
                                        'then' => '$hours_entries.hours', // Path updated
                                        'else' => 0,
                                    ],
                                ],
                            ],
                            'billable' => [
                                '$sum' => [
                                    '$cond' => [
                                        'if' => [
                                            '$and' => [
                                                ['$ne' => ['$hours_entries.project_code', 'CEG']],
                                                ['$not' => ['$in' => ['$hours_entries.project_code', $internalProjectCodes]]],
                                            ],
                                        ],
                                        'then' => '$hours_entries.hours', // Path updated
                                        'else' => 0,
                                            ],
                                        ],
                                    ],
                            'total_hours' => ['$sum' => '$hours_entries.hours'], // Path updated
                        ],
                    ],

                    // Stage 8: Project the final structure (Unchanged)
                    [
                        '$project' => [
                            '_id' => 0,
                            'employee_name' => '$_id.name',
                            'employee_id' => '$_id.employee_id',
                            'expected_billable' => '$expected_billable',
                            'pto' => '$pto',
                            'holiday' => '$holiday',
                            'other_200' => '$other_200',
                            'other_nb' => '$other_nb',
                            'total_nb' => [
                                '$add' => ['$pto', '$holiday', '$other_200', '$other_nb'],
                            ],
                            'billable' => '$billable',
                            'total_hours' => '$total_hours',
                            'billable_percentage' => [
                                '$cond' => [
                                    'if' => ['$gt' => ['$total_hours', 0]],
                                    'then' => [
                                        '$multiply' => [['$divide' => ['$billable', '$total_hours']], 100],
                                    ],
                                    'else' => 0,
                                ],
                            ],
                            'overtime' => [
                                '$cond' => [
                                    'if' => ['$gt' => ['$total_hours', 80]],
                                    'then' => ['$subtract' => ['$total_hours', 80]],
                                    'else' => 0,
                                ],
                            ],
                        ],
                    ],

                    // Stage 9: Sort the results by employee name (Unchanged)
                    [
                        '$sort' => [
                            'employee_name' => 1
                        ]
                    ]
                ];
        
        - Besides Aggregation Pipeline Efficiency, there are some smaller details to pay attention to. If your aggregation pipeline might need to dynamically remove an empty stage like we might need to do in the above example, you must use array_values to re-index the array.
            Bad example:
                 // Remove null stage if no user filters are active
                $pipeline = array_filter($pipeline); // Will not reindex and will later fail!

            Good example:
                 // Remove null stage if no user filters are active
                $pipeline = array_values(array_filter($pipeline));

        - After we run the pipeline, we will use the toArray() method to work with just the actual data, and not Eloquent Model instances
            Bad example:
                $cursor = Hour::raw(function ($collection) use ($pipeline) {
                    return $collection->aggregate($pipeline);
                });
                $models = iterator_to_array($cursor);

            
            Good example:
                $results = Hour::raw(function ($collection) use ($pipeline) {
                    return $collection->aggregate($pipeline);
                })->toArray();

Other Misc Rules:
    1) There is a file called helpers.js under resources/js that holds commonly used functions across many webpages. This is so if we need to make a change to a function that is used in multiple webpages, we can do so in one place instead of many.
        - All of these functions will start with the word "help"
        Current functions inlcude:
            /**
            * Generates initials from a full name.
            * - Single name: Returns the first two letters.
            * - Multiple names: Returns the first letter of the first and last name.
            * @param {string} name The full name.
            * @returns {string} The generated initials in uppercase.
            */
            export function help_generate_initials(name){...},

            **
            * Selects a consistent color palette based on string initials.
            * Uses a simple hashing algorithm to ensure the same initials always get the same color.
            * @param {string} initials The initials to generate a color for.
            * @returns {{background: string, text: string}} An object with TailwindCSS color classes.
            */
            export function help_get_avatar_colors(initials){...}